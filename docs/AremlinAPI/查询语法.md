> Aremlin是Gremlin的一个多维度变种，是一种面向路径的图查询语言，可以简洁地表示复杂的图遍历和转换操作。Aremlin查询语句是从左到右来解析的一串操作/函数。

语法概览：  
预聚合过滤 - 对应语句：.has("",..).by(Predicte)；是一种谓词下推查询，查询数据库中存储的已按Schema聚合完成的数据。  
后聚合过滤 - 对应语句：.groupBy("",..) .where().by(Predicte)；这是在内存中完成的再一次聚合（groupBy），并重新执行过滤。  
数据处理 - 对应语句：.transform("",..).by(Funtion).as("",..)；通过转换函数来更改属性，并映射到别名上作为新属性。  
选择/排除 - 对应语句：.selectProps("",...) / .excludeProps("",...)；用于定义要返回/去除的属性。  
局部维度视图 - 对应语句：.dimE("") / .dimV("") ; 对指定维度运行数据查询规则。  
全局维度视图 - 对应语句：.global() / .globalV(...) / .globalE(...) ; 对其中和（.dimEs/.dimVs）所有指定的维度运行数据查询规则。  

#### KnowledgeId
KnowledgeId描述了AbutionGraph的基本数据格式，它是EntityId和EdgeId的父类。在Abution中，EntityId和EdgeId都表示为一个或多个维度模型的共同Key，也可以叫做”CubeId”。它主要用于其余操作中作为输入的数据 - Entity/Edge的简单表示。    
注意：需要在操作链中进行相同数据转换请参看Output的ToEntityIds操作章节。  

**1）EntityId（EntityKey）**  
EntityId（EntityKey）是Entity的Vertex（顶点），它主要用作查询的输入。
```java
EntityId vertex = new EntityKey("张三");
```

**2）EdgeId（EdgeKey）**  
EdgeId（EdgeKey）是Edge的简单表达，是多维关系数据的共同边，三元组结构（"source", "target", "directed"），它主要用作查询的输入。
```java
EdgeId edgeId = new EdgeKey("source", "target", true);
```

g: 我们当前在使用的图  
V: 该图中的顶点    
注意：首字母大写则为连接到一个新的功能上，功能自身的语法参数则为首字母小写。  

Ps：以下功能的输入和输出一般都是一个Iterable<?>对象。  

#### V()  
输入： ***Vertex（Object类型）、EntityId、无输入则全表查找***    
输出： ***Entities***    
参数：  
```java
dim(String vLabel)：选择Entity的维度，后可接一些数据过滤语法
 *  .dim("")
 *     .has("",..).by(Predicte)                               // PreAggFilter, 支持多属性输入,支持UDF. 调用方式P.*
 *     .groupBy("",..) .where().by(Predicte)                  // PostAggFilter,支持多属性输入,支持UDF. 调用方式P.*
 *     .transform("",..).by(Funtion).as("",..)                  // 属性转换并扩展为新的属性
 *     .selectprops("",...)                                  // 返回时只提取这些属性
 *     .excludeProps("",...)                                 // 返回时排除掉这些属性
dims(String... vLabel)：多选Entity的维度，后可接一些全局的数据过滤语法，如果为空则选择所有维度
 *  .dims("")
 *     .has("",..).by(Predicte)                               // PreAggFilter, 支持多属性输入,支持UDF. 调用方式P.*
 *     .groupBy("",..) .where().by(Predicte)                  // PostAggFilter,支持多属性输入,支持UDF. 调用方式P.*
 *     .transform("",..).by(Funtion).as("",..)
 *     .selectprops("",...)
 *     .excludeProps("",...)
```

#### E()  
输入：EdgeId、无输入则全表查找  
输出：Edge  
参数：
```java
dim(String eLabel)：选择Edge的维度，后可接一些数据过滤语法
 *  .isDirected()                                       // 边有向
 *  .unDirected()                                      // 边无向
 *  .dim("")
 *     .has("",..).by(Predicte)                          // PreAggFilter, 支持多属性输入,支持UDF. 调用方式P.*
 *     .groupBy("",..) .where().by(Predicte)            // PostAggFilter,支持多属性输入,支持UDF. 调用方式P.*
 *     .transform("",..).by(Funtion).as("",..)            // 属性转换并扩展为新的属性
 *     .selectprops("",...)                              // 返回时只提取这些属性
 *     .excludeProps("",...)                                 // 返回时排除掉这些属性
dims(String... eLabel)：多选Edge的维度，后可接一些全局的数据过滤语法，如果为空则选择所有维度
 *  .isDirected()                                           // 边有向
 *  .unDirected()                                          // 边无向
 *  .dims("")
 *     .has("",..).by(Predicte)                           // PreAggFilter, 支持多属性输入,支持UDF. 调用方式P.*
 *     .groupBy("",..) .where().by(Predicte)             // PostAggFilter,支持多属性输入,支持UDF. 调用方式P.*
 *     .transform("",..).by(Funtion).as("",..)
 *     .selectprops("",...)
 *     .excludeProps("",...)
```

#### K()
获取Knowledge操作。V和E的结合，可同时获取Edge/Entiy。  
输入：KnowledgeId（EdgeId/EntityId）、无输入则全表查找  
输出：Knowledges（Edge/Entity）  
参数：
```java
 *
 *  .isDirected()                                         // 边有向
 *  .unDirected()                                        // 边无向
 *
 *  .dimE("")
 *     .has("",..).by(Predicte)                  
 *     .groupBy("",..) .where().by(Predicte)         
 *     .transform("",..).by(Funtion).as("",..)
 *     .props("",...)
 *     .excludeProps("",...)
 *
 *  .dimV("")...
 *
 *  .dimEs("",...)
 *  .dimVs("",...)
 *
 *  .global()
 *     .has("",..).by(Predicte)            
 *     .groupBy("",..) .where().by(Predicte)
 *     .transform("",..).by(Funtion).as("",..)
 *     .props("",...)
 *     .excludeProps("",...)
 *
```java

#### Out()/In()/Both()
GetNeighborIds，获取一度邻居节点。  
输入：Vertex（Object）、EntityId（EntityKey）  
输出：EntityId（EntityKey）  
参数：
```java
 *  .dim("")。。。                                         // 延边的一些属性过滤Pre/Post
 *  .dims("")。。。                                        // 延边的一些全局属性过滤Pre/Post
 *  .dirIsOut()/dirIsIn()/dirIsBoth()                          // 一层的方向，括号中可选参数true/false为是否有向边
```

#### OutV()/InV()/BothV()
GetNeighborEtity，获取一度邻居实体。  
输入：Vertex（Object）、EntityId（EntityKey）  
输出：Entities  
参数：
```java
 *  .dim("")。。。                                         // 延边的一些属性过滤Pre/Post
 *  .dims("")。。。                                        // 延边的一些全局属性过滤Pre/Post
 *  .dirIsOut()/dirIsIn()/dirIsBoth()                          // 一层的方向，括号中可选参数true/false为是否有向边
```

#### OutE()/InE()/BothE()
GetEdge，获取直接关联关系。  
输入：Vertex（Object）、EntityId（EntityKey）、EdgeId（EdgeKey）  
输出：Entities  
参数：
```java
 *  .dim("")。。。                                         // 延边的一些属性过滤Pre/Post
 *  .dims("")。。。                                        // 延边的一些全局属性过滤Pre/Post
 *  .dirIsOut()/dirIsIn()/dirIsBoth()                          // 一层的方向，括号中可选参数true/false为是否有向边
```

#### Store()/StoreDb()/StoreGraph()
临时结果存储（内部是一个Map），相同Key的value会累加。  
Store采用内存存储，StoreDb针对大量数据使用数据库存储，Store和StoreDb可以存储任何数据，而StoreGraph则是只能将上一步得到的Iterable<? extends Knowledge>保存到其它graph中。  
输入：任意对象、无输入则使用默认空间  
输出：将输入原封不动输出  
参数：
```java
 *  key：名称
```
其中，StoreGraph有三个参数：
1. graphId是导出图的名称，不存在则新建；
2. Schema是导出图的数据结构，缺省则在元数据库中获取，否则沿用当前操作图的schema加入到导出图；
3. Properties是导出图的图配置，缺省则沿用当前操作图的配置加入到导出图；

#### Select()/SelectDb()/SelectMap()
查询临时结果缓存。  
输入：操作组合： .Restart().Select(“key”)，意为无输入，重新开始一个子计算链。  
输出：Object；（SelectMap则为Map<String,Object>）  
参数：
```java
 *  key：名称
 *
 *  针对SelectMap()：.setExports() .dbExports() ，指定从Store里获取还是StoreDb里获取中间结果。
```

#### SetVariable()
临时结果存储（内部是一个Map），相同Key的value会累加。    
输入：任意对象、无输入则使用默认空间  
输出：将输入原封不动输出  
参数：
```java
 *  key：名称
```

#### GetVariable()/GetVariables()
获取结果存储，与Store不同之处是此操作会替换掉同key的原有值，而不是累增。  
输入：任意对象、无输入则使用默认空间  
输出：Object；（GetVariables则为Map<String,Object>）  
参数：
```java
 *  key：名称
```

#### WithinE()/WithinK()
WithinE（获取EntityIds中有直接关联的所有Edge）。
WithinK（获取EntityIds中有直接关联的所有Edge和与边匹配的所有Entity）。  
注意：临时内存图实例中该算法不可用。  
输入：Vertex（Object）、EntityId（EntityKey）  
输出：Entities  
参数：
```java
WithinE：
 *  .dim("")。。。                                    // 延边的一些属性过滤Pre/Post
 *  .dims("")。。。                                   // 延边的一些全局属性过滤Pre/Post
 *  .isDirected()/.unDirected()                        // 是否有向边，默认双向
WithinK：
 *  .dimV("")/dimE("")。。。                          // 挑选Entity或者Edge
 *  .dimVs("")/dimVs("")。。。                        // 多选Entity或者Edge，可后接一些全局属性过滤条件
 *  .global()。。。                                    // Entity和Edge的全局过滤条件Pre/Post，命中则应用条件
 *  .isDirected()/.unDirected()                         // 是否有向边，默认双向
```

#### BetweenE()/BetweenK()
BetweenE：获取AB两个EntityIds集合间有直接相连的所有Edge。  
BetweenK：获取AB两个EntityIds集合间有直接相连的所有Edge和与边匹配的所有Entity。  
注意：临时内存图实例中该算法不可用。  
输入：inputA：Vertex（Object）、EntityId（EntityKey）; inputB：Vertex（Object）、EntityId（EntityKey）。 其中inputB作为参数输入。  
输出：Entities  
参数：
```java
BetweenE：
 *  .dim("")。。。                                     // 延边的一些属性过滤Pre/Post
 *  .dims("")。。。                                    // 延边的一些全局属性过滤Pre/Post
 *  .isDirected()/.unDirected()                         // 是否有向边，默认双向
BetweenK：
 *  .dimV("")/dimE("")。。。                           // 挑选Entity或者Edge
 *  .dimVs("")/dimVs("")。。。                         // 多选Entity或者Edge，可后接一些全局属性过滤条件
 *  .global()。。。                                     // Entity和Edge的全局过滤条件Pre/Post，命中则应用条件
 *  .isDirected()/.unDirected()                         // 是否有向边，默认双向
```

#### While()
循环执行多次gql语句。  
输入：任意Object  
输出：Gql最终执行结果  
参数：
```java
 *  .gql(G.*, G.* ...)                                      // 需要遍历的语句，可以通过对象G.调用具体功能
 *  .maxRepeats()                                        // 最大循环次数
 *  .condition(Predicate)                                  // 自定义提前终止条件，即false时
 *  .transform(G.*).condition(Predicate)                    // 每此循环结束后的结果应用处理
```

#### ToVertices()
从Knowledge中提取Id。  
输入：Knowledges（Entities/Edges）  
输出：Object（Vertex、Source、Target）  
参数：
```java
1）边的顶点的提取方案，edgeExtract参数：
1.extSource()        只取边的源点
2.extTarget()         只取边的终点
3.extBothE()         取边的源点和终点
4.extNoneE()         丢弃边数据
2）边的顶点的提取方案，isHitSelect参数：
1.hitSelectEqual()      返回命中查询的边的顶点（源点或终点）
2.hitSelectOpposite()   返回命中查询的边的顶点的相邻顶点
3.hitSelectIgore()      忽视命中查询的边的顶点（源点或终点）-将不会出现在结果中  
注意：1）的优先级大于2），并且俩个提取方案只能应用其一。
```

#### ToEntityIds()/ToKnowIds()

1）ToEntityIds：节点转实体Id对象（内部图原子数据结构），一般用于ToVertices之后。  
输入：Object（Vertex、Source、Target）  
输出：EntityId  
参数：
无

2）ToKnowIds：将Knowledges提取为KnowIds（EntityId/EdgeId）。  
输入：Knowledges  
输出：KnowledgeId  
参数：
无

3）ToKnowledgeId函数
将Knowledges(Entity/Edge)转换为KnowledgeId（EntityId/EdgeId）。  
注意：Gql中的ToKnowIds 区别于Jfunc中的ToKnowledgeIds，后者主要用在函数(ItFunc)内部作为一个转换函数使用。
示例：
```java
  //使用Map遍历集合，使用ToKnowledgeId对每个元素执行转换操作。
  .Map(F.ItFunc(F.ToKnowledgeId())).exec();
```

#### Max()/Min()/Sort()
针对Knowledge的函数操作。注意：最好只输入一个维度的数据，而不是不相干的维度数据也放进来计算。  
输入：Knowledges  
输出：Knowledge  
参数：
```java
 * Max/Min:
 *  .dims("entity","edge",...)                        // 选择需要计算的维度，未选择的维度将不参与计算
 *      .propertyDataType("count")
 * Sort:
 *  .dims("entity","edge",...)
 *      .propertyDataType("property").asc/desc()
 *  .limit()
 *  .dedup()
```

**Sort使用示例：**
```java
//测试数据：
Entity entity1 = Knowledge.dimV("dim")
        .vertex(110)
        .property("key", 3)
        .build();
Entity entity2 = Knowledge.dimV("dim")
        .vertex(111)
        .property("key", 1)
        .build();
Entity entity3 = Knowledge.dimV("dim")
        .vertex(110)
        .property("key", 2)
        .build();
Entity entity4 = Knowledge.dimV("dim1")
        .vertex(114)
        .property("key1", 4)
        .build();
Entity entity5 = Knowledge.dimV("dim1")
        .vertex(115)
        .property("key1", 5)
        .build();
//排序语句：
Sort sort = G.Sort()
        .input(entity1, entity2, entity4, entity3, entity5)
        .dims("dim").propertyInteger("key").asc()
        .resultLimit(100)
        .build();
//执行结果：
System.out.println(Lists.newArrayList(g.execute(max, new User())));
```
```java
[Entity[vertex=111,dimension=dim,properties=Properties[key=<java.lang.Integer>1]], Entity[vertex=110,dimension=dim,properties=Properties[key=<java.lang.Integer>2]], Entity[vertex=110,dimension=dim,properties=Properties[key=<java.lang.Integer>3]], Entity[vertex=115,dimension=dim1,properties=Properties[key1=<java.lang.Integer>5]], Entity[vertex=114,dimension=dim1,properties=Properties[key1=<java.lang.Integer>4]]]
```

自定义比较函数的实现示例
```java
1）PropertyComparatorUDF实现示例：
    private static class PropertyComparatorImpl implements Comparator<Object> {
        @Override
        public int compare(Object o1, Object o2) {
            return ((Integer) o1).compareTo((Integer) o2);
        }
      }
2）KnowledgeComparatorUDF实现示例：
    private static class KnowledgeComparatorImpl implements Comparator<Knowledge> {
        @Override
        public int compare(Knowledge o1, Knowledge o2) {
            int v1 = (int) o1.getProperty("property1") * (int) o1.getProperty("property2");
            int v2 = (int) o2.getProperty("property1") * (int) o2.getProperty("property2");
            return v1 - v2;
        }
      }
3）应用比较函数示例：
 Sort sort = new Sort.Builder()
      .comparator(new KnowledgeComparatorImpl())
      .build();
```

#### Limit()
数据量限制。  
输入：Knowledges  
输出：Knowledges  
参数：无  
limit：最大数量

#### Restart()
RestartChain-重新开始一个子计算链，可以在任何步骤后使用，使用后即开始了一个新分支，注意输入。  
输入：无。下链操作需要声明输入参数input，即从这个输入重新开始计算。  
输出：无。

#### Map()
数据转换，可以在任何得到可迭代结果的步骤后使用，自定义Lambda函数可以做自己想做的任何处理。  

输入：Iterable<? extends T>  
输出：Object（数据转换后的最终结果类型）  
参数：
```java
*  .form：第1步处理的函数，g.V().Map(ele-> ele)。
如转换集合每个元素：g.V().Map().from(F.ItFunc(ele-> ele)); = g.V().Map(F.ItFunc(ele-> ele));
*  .then：第n步处理的函数，可有任意多个then步骤，如：g.V().Map(ele-> ele).then(ele-> ele).then(ele-> ele.toString());
```

**例 - 输入Kowledge,输出KowledgeId**
输入：Iterable<? extends Kowledge>
处理：g.V().Map(F.ItFunc(F.ToKnowledgeId())).exec()  
输出：Iterable<? extends KowledgeId>

**例 - 将inpu数据应用一系列F函数进行处理**
```java
Long res = g.V().Map()
        .from(Object::toString)
        .then(Integer::parseInt)
        .then(i -> (long) i)
        .exec();
```

**例 - 使用F.ItFunc函数迭代每个Item**
```java
// Given
final Iterable<Iterable<Integer>> input = Arrays.asList(
        Arrays.asList(1, 2, 3),
        Arrays.asList(4, 5, 6),
        Arrays.asList(7, 8, 9));

// GQL
final Map<Iterable<Iterable<Integer>>, String> operation = G.<Iterable<Iterable<Integer>>>Map()
        .input(input)
        .from(F.ItFunc()
                .from(F.ItNthItem(1))
                .then(Object::toString)
                .build())
        .then(F.ItNthItem(2))
        .build();

// Execute
final String results = addg.execute(operation, new User());

// Result
System.out.println(results); // 8
```

**例 - 提取每条Path中的起始元素（使用ItFunc）**
此示例中，我们使用Map操作检索"entityDimension"维度的元素，然后从中提取第一个元素。  
本示例演示了在Map操作中将带有ExtractPathEdgesFromHop和FirstItem函数的ItFunc（Lazily懒惰地将函数应用于迭代中的每个项目）应用到GetPath操作的每条Path上，将起始元素（输入ID）提取出来。  
使用此有向图：
```java
    --> 4 <--
  /     ^     \
 /      |      \
1  -->  2  -->  3
         \
           -->  5
Set<? extends java.lang.Iterable<? extends Object>> res = g.V(1,2).Path()
                .gqls( G.GetEdge().dim("edge").build())
                .limit(100)
        .Map(F.<Path>ItFunc()     // 除了使用系统已有的Jfunc函数外,还可以使用UDF函数
                .from(new ExtractPathEdgesFromHop(0))   // 从一个Path中提取指定下标索引的边/边集
                .then(F.ItFirstItem())                  // 提取每个边集的第一个元素（若边集只有一条边,则还是它,即数组第1个）
                .build())
        .ToVertices().extSource()                       // 提取边的源点-即起始点
        .ToSet()                                        // 去重操作
        .exec(new User());
```
得到结果，可以看到他们是输入的节点Id：  
1  
2  


#### Reduce()
使用提供的Agg函数将任意类型的Iterable输入归并为单个输出值。对于开发者自定义实现，功能类可继承JfuncFunction<输入类型, 输出类型>。  
输入：Iterable<? extends Object>  
输出：Object（数据转换后的最终结果类型）  
参数：  
1. mergeValue：需要加入合并的数据，数据类型需一致
2. aggFunction：聚合函数

例 - 计算每个邻居的下跳节点汇总（使用ForEach+Reduce）
此示例中，我们使用Map操作检索"entityDimension"维度的元素，然后从中提取第一个元素。
使用此有向图：
```java
    --> 4 <--
  /     ^     \
 /      |      \
1  -->  2  -->  3
         \
           -->  5
g.V(1).Both().ForEach()
        .gql(G.GetNeighborIds().ToVertices().Reduce(Agg.Sum()).getChain())
	.exec();
```
得到结果，可以看到节点1的邻居2的邻居节点汇总为13，节点1的邻居4的邻居节点汇总为6：
13
6

Reduce还有一个参数mergeValue：作为与与之聚合的初始值。
```java
var graph = G.GetGraph("tgTelecom3", new User(), "/thutmose/app/abution/conf/store.properties");
Iterable<Integer> input = Arrays.asList(1, 2, 3);

Reduce<Integer> reduce = G.<Integer>Reduce().
        input(input).
        //mergeValue(5).
        aggFunction(Agg.Sum()).
        build();
System.out.println(Lists.newArrayList(g.execute(reduce, new User())));
// 结果为6

Iterable<Integer> input = Arrays.asList(1, 2, 3);

Reduce<Integer> reduce = G.<Integer>Reduce().
        input(input).
        mergeValue(5).
        aggFunction(Agg.Sum()).
        build();
System.out.println(Lists.newArrayList(g.execute(reduce, new User())));
// 结果为11
```

#### ForEach()
对输入的集合轮循，可以在每一个轮循里做一些Gql操作。  
输入：Iterable<? extends T>  
输出：Object（gql执行后的最终结果类型）  
参数：
 *  .gql(Gql)：可以从对象G.中获得具体功能，并串联成从左至右执行的功能链

假设：  
	input =     [  [1,2,3],  [4,5],  [6]  ]  
经过：  
  operation = Count  
结果：  
  results =   [  [3],  [2],  [1]  ]  

**例 - 操作链中使用ForEach**
使用此有向图：
```java
    --> 4 <--
  /     ^     \
 /      |      \
1  -->  2  -->  3
         \
           -->  5
g.V(1).Both().ForEach()
        .gql(G.ToEntityIds().Both().ToVertices().getChain())
        .exec();
```
得到结果如：
[ 3 --> 4 --> 5 --> 1 ]
[ 1 --> 2 --> 3 ]

#### Aggregate()
Aggregate用于采用自定义方法汇总上步得到的Knowledges，是一个postAgg操作。  
输入：Iterable<? extends Knowledge>  
输出：Iterable<? extends Knowledge>  
参数：
```java
 *  .dimE("")                      //选择要聚合的Edge维度数据
 *    .groupBy("",...)              //选择维度列
 *      .where("",..).agg(Agg)      //选择聚合列，并指定应用的聚合函数
 *  .dimV("")
 *    .groupBy("",...)
 *      .where("",..).agg(Agg)
```

数据聚合规则：
1. 将对input按先后顺序两两聚合，Knowledge的基本属性（节点/源点/终点属性+groupBy属性）相同时才能发生聚合，否则原封不动输出。  
2. 基于1，如果维度下有多个where().agg()语句，将按照顺序执行，第一个where().agg()的结果将替换掉两两聚合中的第一个Knowledge，传递到第二个where().agg()计算语句的时候输入为（聚合过的第一个Knowledge，原始的第二个Knowledge），再通过Agg函数发生过聚合，依次类推。

**例 - 使用UDF聚合属性**  
使用以下3条输入数据测试：
```java
Entity entity1 = Knowledge.dimV("Dim")
        .vertex("110")
        .property("prop1", "Abution1")
        .property("count", 1)
        .build();
Entity entity2 = Knowledge.dimV("Dim")
        .vertex("110")
        .property("prop1", "Abution2")
        .property("count", 2)
        .build();
Entity entity3 = Knowledge.dimV("Dim")
        .vertex("110")
        .property("prop1", "Abution3")
        .property("count", 2)
        .build();
```
定义聚合规则：
```java
.Aggregate()
        .dimV("Dim").groupBy("count")
            .where("prop1","count").agg((x,y)-> {
                String x1 = ((Tuple2)x).get0().toString();
                Integer x2 = (Integer)(((Tuple2)x).get1());
                String y1 = ((Tuple2)y).get0().toString();
                Integer y2 = (Integer)(((Tuple2)y).get1());
                return new Tuple2<>(x1+","+y1 , x2+y2);
	    });
```
得到结果：
[{"dimension":"Dim","vertex":"110","properties":{"prop1":"Abution1","count":1}},
{"dimension":"Dim","vertex":"110","properties":{"prop1":"Abution2,Abution3","count":4}}]

#### Filter()
根据条件过滤Knowledges，即上一步得到的结果。  
输入：Iterable<? extends Knowledge>  
输出：Iterable<? extends Knowledge>  
参数：
```java
 *  .dimE("")                       //选择要过滤的Edge维度数据
 *     .has("",..).by(Predicte)     //选择过滤列，并指定应用的过滤函数
 *  .dimV("")...
 *  .global()                       //全局过滤，只要具有过滤列，则应用过滤函数
 *     .has("",..).by(Predicte)
```

**例 - 过滤所有count>2的元素**  
使用此有向图：
```java
    --> 4 <--
  /     ^     \
 /      |      \
1  -->  2  -->  3
         \
           -->  5
g.V().Filter().global().has("count").by(P.MoreThan(2)).exec();
```
得到结果如：  
```text
  Entity[vertex=1,dimension=entity,properties=Properties[count=<java.lang.Integer>3]]
  Edge[source=1,target=2,directed=true,matchedVertex=SOURCE,dimension=edge,properties=Properties[count=<java.lang.Integer>3]]
```
可见输入数据1-(1)->4, 1-(3)->2中，1-(1)->4属性小于2，已被过滤。

#### Transform()
转换操作，用于转换先前操作得到的Knowledges，并将更改后的值作为新属性（别名）加入到Knowledge中。  
输入：Iterable<? extends Knowledge>  
输出：Iterable<? extends Knowledge>  
参数：
```java
 *  .dimV("")                                     //选择要转换的Entity维度数据
 *      .trans("",..).by(Function).as("别名",...)
 *      .trans("",..).by(Function).as("别名",...)...
 *  .dimE("")
 *      .trans("",..).by(Function).as("别名",...)...
```
语法：  
  trans("xx")，即选择要转换的xx属性  
  by( func )，即对xx属性应用什么处理逻辑，可使用F.func挑选函数，也可以编写Lambda自定义函数  
  as("yy")，即定义属性别名，用于存储经过func处理的"xx"属性。  

此外，您还可以trans任何这些IdType：  
  - IdType.VERTEX - 实体顶点
  - IdType.SOURCE - Edge源点
  - IdType.TARGET - Edge终点
  - IdType.DIRECTED - Edge上的目标顶点
  - IdType.MATCHED_VERTEX - 查询中命中的顶点，SOURCE或TARGET
  - IdType.ADJACENT_MATCHED_VERTEX - 在查询中命中的邻居顶点，SOURCE或TARGET。即如果您的节点匹配了Edge的TARGET，该值就为TARGET，反之为SOURCE。


**1.例 - 转换count属性为字符串类型**
例 - 转换edge维度的count属性为字符串类型
```java
g.V().OutE().Transform()
        .dimE("edgeDim").trans("count").by(F.ToString()).as("countStr").exec();
```

**2.例 - 编写自定义转换函数**
场景：将金融原始数据中的属性交易时间”jyqr”复制成两个别名为”startTime”和”stopTime”的属性，目的是可用于后续扩充自定义时间窗口的聚合。
```java
g.V().OutE().Transform()
        .dimE("KaKa-RawData")
        .trans("jyrq").by(i-> {
            Tuple2<Date,Date> tuple2 = new Tuple2<>();
            tuple2.put0((Date)i);
            tuple2.put1((Date)i);
            return tuple2;
        }).as("startTime","stopTime").exec();
```
以上方法同下：
```java
g.V().OutE().Transform()
        .dimE("KaKa-RawData")
            .trans("jyrq").by(F.IntactOut()).as("startTime")
            .trans("jyrq").by(F.IntactOut()).as("stopTime")
        .exec();
```

多属性的转换方法：
```java
g.V().OutE().Transform()
        .dimV("dim").trans("p1","p2").by(new ConcatFunc()).as("p12").exec();

public static class ConcatFunc  extends JfuncFunction2<String, Integer, String> {
    @Override
    public String apply(String input1, Integer input2) {
        return input1+"-"+input2;
    }
}
```
如上示例，我们提取了两个属性（p1,p2），并应用了自定义函数ConcatFunc。注意，对于Java Lambda多参数输入，请将UDF提取到独立类中实现。

#### Count()
统计Iterable的数量。  
输入：Iterable<? extends Object>  
输出：Long  
参数：
 *  无

#### CountDims()
统计Knowledges中dimension的数量。  
输入：Iterable<? extends Knowledge>  
输出：DimsCounter（包含了entityDim和edgeDim分别的数量）  
参数：
 *  limit：数据量限制

#### If()
与编程语言中条件判断语句If一样，它实现一个if..then..else语句，即如果condition=true，执行then，否则执行otherwise。  
输入：Object  
输出：执行Gql的结果  
参数：
```java
 *  .transform(Gql).condition(Predicate)
 *  .condition(Predicate)
 *  .then(Gql)
 *  .otherwise(Gql)
```
其中，.transform(Gql).condition(Predicate) 与 condition(Predicate) 是同级的，前者先运行一个数据处理操作再使用条件判断，后者则直接对输入数据做条件判断。  

**1.例 - 有条件地获取元素或限制当前结果**
此示例将使用与ID为2的实体相邻的顶点，如果结果少于5个，则将它们传递到GetKnowledge操作中，否则仅返回5个结果。  
```java
//使用该有向图：
                 --> 7 <--
               /           \
              /             \
             6  -->  3  -->  4
 ___        ^         \
|   |       /          /
 -> 8 -->  5  <--  2  <
          ^        ^
         /        /
    1 --         /
     \          /
       --------

Iterable<? extends Object> result = g.V(2).Both().If()
        .transform(G.Limit(6))
        .condition(P.LenMoreThan(5))
        .then(G.GetKnowledge().Limit(5).getChain())
        .otherwise(G.Limit(5))
        .exec();
```
得到结果：
```text
Entity[vertex=5,dimension=cardinality,properties=Properties[...]]
Entity[vertex=5,dimension=cardinality,properties=Properties[...]
Entity[vertex=5,dimension=entity1,properties=Properties[count=<java.lang.Integer>3]]
Edge[source=5,target=6,directed=true,matchedVertex=SOURCE,dimension=edge1,properties=Properties[count=<java.lang.Integer>11]]
Edge[source=1,target=5,directed=true,matchedVertex=TARGET,dimension=edge,properties=Properties[count=<java.lang.Integer>6]]
```

**2.例 - 自定义Condition**  
```java
g.V(1,2,3).K().dimVs().If()
        .transform(G.Limit(3)).condition(x-> {
            return Iterables.size((Iterable)x) > 2;
        })
        .then(G.GetKnowledge().input("13001000955").dimVs().Limit(5).getChain())
        .otherwise(G.Limit(2))
        .exec();
```

#### While()
当While满足条件时重复执行操作，它将在condition=true时执行提供的operation，在到达最大跳数限制（setMaxRepeats）或者某些条件为false时停止执行操作。  
输入：Object  
输出：执行Gql的结果  
参数：
```java
 *  .maxRepeats()
 *  .condition(Predicate)
 *  .transform(G.Operation).condition(Predicate)
 *  .gql(Gql)
```

**例 - 获取3跳邻居**  
此示例中，我们使用While循环运行运行GetNeighborId操作3次。
```java
//使用此有向图：
                 --> 7 <--
               /           \
              /             \
             6  -->  3  -->  4
 ___        ^         \
|   |       /          /
 -> 8 -->  5  <--  2  <
          ^        ^
         /        /
    1 --         /
     \          /
       --------
g.V(1).ToEntityIds().While()
        .maxRepeats(3)
        .gql(G.GetNeighborIds().dirIsOut().build())
        .exec();
```
得到结果：
```text
  EntityKey[vertex=6]
  EntityKey[vertex=3]
  EntityKey[vertex=7]
```

**例 - 获取3跳邻居的路径(Path)**  
此示例中，我们使用While循环运行运行GetPath操作3次来遍历并收集路径。  
注意：GetPath可能包含很多的结果，所以它有个参数resultsLimit来限制结果数。

```java
//使用此有向图：
                 --> 7 <--
               /           \
              /             \
             6  -->  3  -->  4
 ___        ^         \
|   |       /          /
 -> 8 -->  5  <--  2  <
          ^        ^
         /        /
    1 --         /
     \          /
       --------
GetPath operation = G.GetPath()
        .input(1)
        .gqls(G.While()
                .maxRepeats(3)
                .gql(G.GetKnowledge().dirIsOut().build())
                .build())
        .build();
```
得到结果：
```text
cn.thutmose.abution.graphdb.data.g.Path[ 1 --> 5 --> 6 --> 3 ]
cn.thutmose.abution.graphdb.data.g.Path[ 1 --> 5 --> 6 --> 7 ]
cn.thutmose.abution.graphdb.data.g.Path[ 1 --> 2 --> 5 --> 6 ]
```

**例 - 持续循环直到找到结果-条件为true**  
此示例中，我们使用While持续运行GetNeighborId，直到结果包含值为7的顶点为止。
```java
//使用此有向图：
                 --> 7 <--
               /           \
              /             \
             6  -->  3  -->  4
 ___        ^         \
|   |       /          /
 -> 8 -->  5  <--  2  <
          ^        ^
         /        /
    1 --         /
     \          /
       --------
g.V(1).ToEntityIds().While()
        //.condition(new ToSet<>(), P.Not(P.ArrayContains(new EntityKey(7)))) //ToSet是Gql,Not是函数. 功能与下condition同：
        .condition(x-> {
            Set<EntityKey> list = Sets.newHashSet((Iterable)x);
            return !list.contains(new EntityKey(7));
        })
        .maxRepeats(20)
        .gql(G.GetNeighborIds().dirIsOut().build())
        .exec();
```
得到结果：
```text
EntityKey[vertex=6]
EntityKey[vertex=3]
EntityKey[vertex=7]
```

**例 - transform().condition().operation()**  
当While满足条件时执行预设操作（使用Map提取条件过滤属性）
```java
// 假设输入数据
Edge input = Knowledge.dimE("testEdge")
        .src("src")
        .dst("dest")
        .directed(true)
        .property("count", 3)
        .build();

// 满足条件时,GetKnowledge才会执行
g.V(1).ToEntityIds().While()
        .maxRepeats(1)
        .transform(G.Map()
                .from(new ExtractProperty("count"))
                .build())
        .condition(P.MoreThan(5))
        .gql(G.GetKnowledge().dimVs().build())
        .exec();
```
Ps：在监控预警系统中，此操作非常有用，我们可以将此操作作为GraphHook在每次入库之后自动执行此操作，当某条数据满足条件时，即立即执行针对该条数据更深层次的分析操作。

#### Path()
获取遍历过程作为路径。注意：此功能在未来会有重大改变和更简易的使用方式。  
输入：VertexId  
输出：Iterable<? extends Knowledge>  
参数：
```java
 *  .gqls(G.*,...)           //遍历过程-顺序执行的一些Gql
 *  .pruning()             //剪枝
 *  .limit()               //结果数限制，默认100w条
```

**例 - 获取所有从顶点1开始的长度为2的路径**  
```java
//使用此有向图：
                 --> 7 <--
               /           \
              /             \
             6  -->  3  -->  4
 ___        ^         \
|   |       /          /
 -> 8 -->  5  <--  2  <
          ^        ^
         /        /
    1 --         /
     \          /
       --------
//限制遍历方向必须为匹配的顶点的出方向。
g.V(1).Path()
    .gqls(G.GetKnowledge().dirIsOut().build(),
            G.GetKnowledge().dirIsOut().build())
    .exec();
```
得到结果，此结果为简化版，真实结果包含实体与关系信息：
```text
cn.thutmose.abution.graphdb.data.g.Path[ 1 --> 5 --> 6 ]
cn.thutmose.abution.graphdb.data.g.Path[ 1 --> 2 --> 5 ]
```

#### WalkEmit()/WalkEmitOutIds()
手动将遍历得到的Knowledge（必须有Edge）按照先后顺序存放入路径收集器WalkCollection（类似ArrayList）全局对象中，这将在遍历完成后可以得到所有遍历过并保存的路径，路径的层数为调用WalkCollection的次数（第一次为0层-起点）。  

输入：Iterable<? extends Knowledge>  
输出：
  1. WalkEmit：原封不动的输出Iterable<? extends Knowledge>
  2. WalkEmitOutIds：输出与查询匹配节点的下一跳节点的id，即Iterable<? extends EntityId>,可用于继续遍历,默认已去重  
参数：
```java
 *  WalkCollection：Walk收集器
```

使用示例（金融资金发散模型）：
```java
public Iterable<Walk> yewu(Graph g, User user, List<Object> startVs, String startDate, String stopDate,
                            double minSumMoney, int maxRepeats, boolean pruning) {

    final WalkCollection walkCollection = new WalkCollection(startVs, maxRepeats, pruning);

    g.V(startVs).While()
            .maxRepeats(maxRepeats)
            .gql(G.GetEntity().dim("Ka")
                        .has("startDate", "stopDate").by(P.DateRangeDualIn(startDate,stopDate))
                        .groupBy().where("outHll").by(P.DCHllMoreThanEq(0L))
                        .Store("Knowledges")
                    .ToEntityIds().ToSet()
                    .V().OutE().dim("JiaoYi")
                        .has("startDate", "stopDate").by(P.DateRangeDualIn(startDate,stopDate))
                        .groupBy().where("outSum").by(P.MoreThanEq(new BigDecimal(minSumMoney)))
                        .Store("Knowledges")
                    .Select("Knowledges")
                    .WalkEmitOutIds(walkCollection)
                    .getChain()
            )
            .exec(user);

    return walkCollection.toPaths();
}
```
示例中使用While从开始起点进行遍历，直到maxRepeats满足则终止遍历，我们使用WalkEmitOutIds收集期中的每一层满足条件的遍历结果（Entity+Edge），并在遍历结束后调用walkCollection.toPaths()方法获得所有起点到终点的walks。  
> Walk有Trail和Path之分，可以从Walk对象中的调用方法进行过滤。
  isTrail：walk不包含任何重复的边；
  isPath：walk不包含重复的顶点；  
  还有过滤死循环、中间是否有环等方法可用。


#### ToList/ToSet/ToArray/ToSingleList/ToStream
将Iterable数据转换为集合类型。注意：转换为集合类型是在内存中完成的，因此建议不要将其用于大量结果。

```java
//使用此有向图：
    --> 4 <--
  /     ^     \
 /      |      \
1  -->  2  -->  3
         \
           -->  5

Knowledge[] res = g.V(1,2).K().ToArray().exec(user);
```
得到结果：
```text
Entity[vertex=2,dimension=entity,properties=Properties[count=<java.lang.Integer>1]]
Edge[source=2,target=3,directed=true,matchedVertex=SOURCE,dimension=edge,properties=Properties[count=<java.lang.Integer>2]]
Edge[source=2,target=4,directed=true,matchedVertex=SOURCE,dimension=edge,properties=Properties[count=<java.lang.Integer>1]]
Edge[source=2,target=5,directed=true,matchedVertex=SOURCE,dimension=edge,properties=Properties[count=<java.lang.Integer>1]]
Edge[source=1,target=2,directed=true,matchedVertex=TARGET,dimension=edge,properties=Properties[count=<java.lang.Integer>3]]
Entity[vertex=1,dimension=entity,properties=Properties[count=<java.lang.Integer>3]]
Edge[source=1,target=2,directed=true,matchedVertex=SOURCE,dimension=edge,properties=Properties[count=<java.lang.Integer>3]]
Edge[source=1,target=4,directed=true,matchedVertex=SOURCE,dimension=edge,properties=Properties[count=<java.lang.Integer>1]]
```
Ps：其它操作使用方法相似，不一一列出。

#### ToCsv/ToMap
数据格式化操作。  
输入：Iterable<? extends Knowledge>  
输出：Iterable<? extends String>  
参数：
```java
 *  translate：（必填）指定一些转换参数
 *  includeHeader：是否包含属性头
```

- 示例ToCsv：
```java
Lists.newArrayList(g.V().Limit(10).ToCsv().translate(F.CsvGenerator()
        .vertex("v").source("src").target("dst")
        .build()).exec(user));
```

- 示例ToMap：
```java
Lists.newArrayList(g.V().Limit(10).ToMap().translate(F.MapGenerator()
        .vertex("v").source("src").target("dst")
        .build()).exec(user));
```

#### FromURL()
从一个URL获取数据，一般使用组合：.Restart().FromURL()。此GQL是一个外部数据获取工具，有网络爬虫的特性，也可作为命令接收器使用，也常用作网页的变动监控。  
参数：
 *  .url("https://mydata.com:8888/mydata")


#### Join
Join操作用于将两个Iterables对象连接在一起，并指定match和merge方法。  
注意：此功能将在未来版本中有大更新；默认将Iterables数量限制为100,000，因为这些可迭代项将作为集合读取到内存中。可以通过在操作中添加指定limit来更改此限制。  

Join的三种联接类型：
1. FULL   - （全连接）返回键中的所有对象，以及另一端的所有匹配对象
2. INNER  - （内连接）返回与另一侧对象匹配的所有键
3. OUTER - （外连接）返回与另一侧对象不匹配的所有键

Join操作可以在左侧（输入）或右侧（指定操作的输出）键入，并输出可迭代的MapTuples。这些元组包含左右输出。

连接操作必须提供match方法。这告诉操作如何确定匹配项和不匹配项。  
Join的两种matchMethod：
1. KnowledgeMatch - 匹配具有相同id，dimension和dimension by属性的元素
2. KeyFunctionMatch - 基于两个Key函数匹配任何左右元素对象。第一个键函数适用于任何联接类型（左键联接的对象在左侧，右键则相反）。

匹配后，左侧和右侧数据将作为MapTuples输出，并以" LEFT"和" RIGHT"为键。默认情况下，输出结果是平铺了的（每个右值配对一个左值）。若将flatten置为false会将"非键控端"数据汇总在列表中。  
```text
flatten=false：  
MapTuple[values={ LEFT=[Knowledge..]], RIGHT=Knowledge..}], ...]  
flatten=true：  
MapTuple[values={ LEFT=Knowledge..], RIGHT=Knowledge..}], ...]  
```

实例：
```java
//使用此有向图：
    --> 4 <--
  /     ^     \
 /      |      \
1  -->  2  -->  3
         \
           -->  5
//全部数据：
Edge[source=3,target=4,directed=true,dimension=edge,properties=Properties[count=<java.lang.Integer>4]]
Edge[source=1,target=4,directed=true,dimension=edge,properties=Properties[count=<java.lang.Integer>1]]
Edge[source=2,target=3,directed=true,dimension=edge,properties=Properties[count=<java.lang.Integer>2]]
Edge[source=2,target=5,directed=true,dimension=edge,properties=Properties[count=<java.lang.Integer>1]]
Edge[source=1,target=2,directed=true,dimension=edge,properties=Properties[count=<java.lang.Integer>3]]
Entity[vertex=2,dimension=entity,properties=Properties[count=<java.lang.Integer>1]]
Entity[vertex=3,dimension=entity,properties=Properties[count=<java.lang.Integer>2]]
Edge[source=2,target=4,directed=true,dimension=edge,properties=Properties[count=<java.lang.Integer>1]]
Entity[vertex=1,dimension=entity,properties=Properties[count=<java.lang.Integer>3]]
Entity[vertex=4,dimension=entity,properties=Properties[count=<java.lang.Integer>1]]
Entity[vertex=5,dimension=entity,properties=Properties[count=<java.lang.Integer>3]]
//取部分作为连接的示例数据：
Entity[vertex=1,dimension=entity,properties=Properties[count=<java.lang.Integer>3]]
Entity[vertex=4,dimension=entity,properties=Properties[count=<java.lang.Integer>1]]
Entity[vertex=5,dimension=entity,properties=Properties[count=<java.lang.Integer>3]]
Entity[vertex=6,dimension=entity,properties=Properties[count=<java.lang.Integer>30]]        <<---图中不存在
```

**例 - 获取全图元素与节点113相关边的交集**
```java
Iterable<? extends Object> inputKnowledges = g.V("113").BothE("EdgeJiaoYi").exec(user);

GqlChain<Iterable<? extends MapTuple>> opChain = new GqlChain.Builder()
        .from(new Join.Builder<>()
                .input(inputKnowledges)                       // Join的另一个结果集
                .gql(new ScanKnowledge().build())          // 获取全部数据
                .joinType(JoinType.INNER)
                .matchKey(MatchKey.RIGHT)                  // 右连接
                .flatten(false)                              // 关掉平铺,默认true
                .matchMethod(new KnowledgeMatch("count")) // 两集合关联的Key(groupByProps),不存在该属性的话将以Knowledge为关联条件
                .limit(10)                        // 数据大小限制为10条
                .build())
        .build();

Iterable<? extends Object> result = g.execute(opChain, userInstance);
System.out.println(IteratorUtils.toList(result.iterator()));
```
返回结果，可以看到我们得到了节点113相关边与全图数据的交集：
```text
[cn.thutmose.abution.jfunc.tuple.MapTuple@3bd55d8[values={
LEFT=[Edge[source=112,target=113,directed=true,matchedVertex=TARGET,dimension=EdgeJiaoYi,properties=Properties[day2=..,day1=..,zje=..]]],
RIGHT=Edge[source=112,target=113,directed=true,dimension=EdgeJiaoYi,properties=Properties[zje=..,day2=..,day1=..]]}],
cn.thutmose.abution.jfunc.tuple.MapTuple@408a247c[values={
LEFT=[Edge[source=113,target=114,directed=true,matchedVertex=SOURCE,dimension=EdgeJiaoYi,properties=Properties[day2=..,day1=..,zje=..]]],
RIGHT=Edge[source=113,target=114,directed=true,dimension=EdgeJiaoYi,properties=Properties[zje=..,day2=..,day1=..]]}]]
当flatten=true时的结果，扁平操作可以理解为一个集合元素平铺为多行展示：
[cn.thutmose.abution.jfunc.tuple.MapTuple@3bd55d8[values={
LEFT= Edge[source=112,target=113,directed=true,matchedVertex=TARGET,dimension=EdgeJiaoYi,properties=Properties[day2=..,day1=..,zje=..]],
RIGHT=Edge[source=112,target=113,directed=true,dimension=EdgeJiaoYi,properties=Properties[zje=..,day2=..,day1=..]]}],
cn.thutmose.abution.jfunc.tuple.MapTuple@408a247c[values={
LEFT= Edge[source=113,target=114,directed=true,matchedVertex=SOURCE,dimension=EdgeJiaoYi,properties=Properties[day2=..,day1=..,zje=..]],
RIGHT=Edge[source=113,target=114,directed=true,dimension=EdgeJiaoYi,properties=Properties[zje=..,day2=..,day1=..]]}]]
```
注意：如上结果为AbutionGDB的产出类型，以下示例为了便于观看采用简洁写法。


**例 - KeyFunctionMatch使用示例**  
KeyFunctionMatch- 基于两个Key函数匹配任何左右元素对象。第一个键函数适用于任何联接类型（左键联接的对象在左侧，右键则相反）。  
1. 例一、相同维度属性关联-ExtractProperty
```java
public void shouldMatchKnowledgesOfTheSameDimensionBasedOnKeyFunctions() {
    // given
    Entity testItem = Knowledge.dimV(TEST_ENTITY_DIMENSION)
            .vertex("test")
            .property(PROP_1, 3L)
            .build();

    List<Entity> testList = Lists.newArrayList(
            Knowledge.dimV(TEST_ENTITY_DIMENSION)
                    .vertex("test2")
                    .property(PROP_1, 2L)
                    .build(),
            Knowledge.dimV(TEST_ENTITY_DIMENSION)
                    .vertex("test3")
                    .property(PROP_1, 3L)
                    .build(),
            Knowledge.dimV(TEST_ENTITY_DIMENSION)
                    .vertex("test1")
                    .property(PROP_1, 4L)
                    .build(),
            Knowledge.dimV(TEST_ENTITY_DIMENSION)
                    .vertex("test3")
                    .property(PROP_1, 3L)
                    .build()
    );

    // when
    KeyFunctionMatch match = new KeyFunctionMatch.Builder()
            .firstKeyFunction(new ExtractProperty(PROP_1))  // 左值
            .secondKeyFunction(new ExtractProperty(PROP_1)) // 右值
            .build();

    match.init(testList);

    // then
    ArrayList<Entity> expected = Lists.newArrayList(
            Knowledge.dimV(TEST_ENTITY_DIMENSION)
                    .vertex("test3")
                    .property(PROP_1, 3L)
                    .build(),
            Knowledge.dimV(TEST_ENTITY_DIMENSION)
                    .vertex("test3")
                    .property(PROP_1, 3L)
                    .build());

    assertEquals(expected, match.matching(testItem));   // 左右都有的property(PROP_1, 3L)元素
}
```

2. 例二、不同维度属性关联-FunctionComposite
```java
@Test
public void shouldMatchKnowledgesOfDifferentDimensionsBasedOnKeyFunctions() {
    // given
    Entity testItem = Knowledge.dimV(TEST_ENTITY_DIMENSION)
            .vertex("test")
            .property(PROP_1, 2L)
            .build();

    List<Entity> testList = Lists.newArrayList(
            Knowledge.dimV(TEST_ENTITY_DIMENSION_2)
                    .vertex("test2")
                    .property(PROP_2, 2)
                    .build(),
            Knowledge.dimV(TEST_ENTITY_DIMENSION)
                    .vertex("test3")
                    .property(PROP_1, 3L)
                    .build(),
            Knowledge.dimV(TEST_ENTITY_DIMENSION)
                    .vertex("test1")
                    .property(PROP_1, 4L)
                    .build(),
            Knowledge.dimV(TEST_ENTITY_DIMENSION_2)
                    .vertex("test3")
                    .property(PROP_2, 2)
                    .build()
    );

    // when
    KeyFunctionMatch match = new KeyFunctionMatch.Builder()
            .firstKeyFunction(new ExtractProperty(PROP_1))
            .secondKeyFunction(new FunctionComposite(Lists.newArrayList(new ExtractProperty(PROP_2), new ToLong())))
            .build();

    match.init(testList);

    // then
    ArrayList<Entity> expected = Lists.newArrayList(
            Knowledge.dimV(TEST_ENTITY_DIMENSION_2)
                    .vertex("test2")
                    .property(PROP_2, 2)
                    .build(),
            Knowledge.dimV(TEST_ENTITY_DIMENSION_2)
                    .vertex("test3")
                    .property(PROP_2, 2)
                    .build());

    assertEquals(expected, match.matching(testItem));
}
```

3. 例三、Edge关联Entity属性-ExtractId
```java
@Test
public void shouldMatchKnowledgesOfDifferentClassesBasedOnKeyFunctions() {
    // given
    Edge testItem = Knowledge.dimE(TEST_EDGE_DIMENSION)  // 匹配模板是Edge
            .src("test1")
            .dst("test4")
            .directed(true)
            .property(PROP_1, 2L)
            .build();

    List<Entity> testList = Lists.newArrayList(                  // 关联元素集是Entity
            Knowledge.dimV(TEST_ENTITY_DIMENSION_2)
                    .vertex("test2")
                    .property(PROP_2, 2)
                    .build(),
            Knowledge.dimV(TEST_ENTITY_DIMENSION)
                    .vertex("test3")
                    .property(PROP_1, 3L)
                    .build(),
            Knowledge.dimV(TEST_ENTITY_DIMENSION)
                    .vertex("test1")
                    .property(PROP_1, 4L)
                    .build(),
            Knowledge.dimV(TEST_ENTITY_DIMENSION_2)
                    .vertex("test3")
                    .property(PROP_2, 2)
                    .build()
    );

    // when
    KeyFunctionMatch match = new KeyFunctionMatch.Builder()
            .firstKeyFunction(new ExtractId(IdType.SOURCE))   
            .secondKeyFunction(new ExtractId(IdType.VERTEX))            // ExtractId从一个knowledge中提取出id
            .build();

    match.init(testList);

    // then
    ArrayList<Entity> expected = Lists.newArrayList(Knowledge.dimV(TEST_ENTITY_DIMENSION)
            .vertex("test1")
            .property(PROP_1, 4L)
            .build());

    assertEquals(expected, match.matching(testItem));
}
```

**例 - 左内联接**
```java
GqlChain<Iterable<? extends MapTuple>> opChain = new GqlChain.Builder()
        .from(new Join.Builder<>()
                .input(inputKnowledges)
                .gql(new ScanKnowledge())
                .joinType(JoinType.INNER)
                .matchKey(MatchKey.LEFT)
                .flatten(false)
                .matchMethod(new KnowledgeMatch("count"))
                .build())
        .build();
```
得到结果：
```text
[ Entity[vertex=1,dimension=entity,properties=Properties[count=<java.lang.Integer>3]]
						--> [Entity[vertex=1,dimension=entity,properties=Properties[count=<java.lang.Integer>3]]] ]
[ Entity[vertex=4,dimension=entity,properties=Properties[count=<java.lang.Integer>1]]
						--> [Entity[vertex=4,dimension=entity,properties=Properties[count=<java.lang.Integer>1]]] ]
[ Entity[vertex=5,dimension=entity,properties=Properties[count=<java.lang.Integer>3]]
						--> [Entity[vertex=5,dimension=entity,properties=Properties[count=<java.lang.Integer>3]]] ]
```

**例 - 右内联接**
```java
GqlChain<Iterable<? extends MapTuple>> opChain = new GqlChain.Builder()
        .from(new Join.Builder<>()
                .input(inputKnowledges)
                .gql(new ScanKnowledge())
                .joinType(JoinType.INNER)
                .matchKey(MatchKey.RIGHT)
                .flatten(false)
                .matchMethod(new KnowledgeMatch("count"))
                .build())
        .build();
```
得到结果：
```text
[ [Entity[vertex=1,dimension=entity,properties=Properties[count=<java.lang.Integer>3]]] --> 	Entity[vertex=1,dimension=entity,properties=Properties[count=<java.lang.Integer>3]] ]
[ [Entity[vertex=4,dimension=entity,properties=Properties[count=<java.lang.Integer>1]]] --> 			Entity[vertex=4,dimension=entity,properties=Properties[count=<java.lang.Integer>1]] ]
[ [Entity[vertex=5,dimension=entity,properties=Properties[count=<java.lang.Integer>3]]] --> 			Entity[vertex=5,dimension=entity,properties=Properties[count=<java.lang.Integer>3]] ]
```

**例 - 左全联接**
```java
GqlChain<Iterable<? extends MapTuple>> opChain = new GqlChain.Builder()
        .from(new Join.Builder<>()
                .input(inputKnowledges)
                .gql(new ScanKnowledge())
                .joinType(JoinType.FULL)
                .matchKey(MatchKey.LEFT)
                .flatten(false)
                .matchMethod(new KnowledgeMatch("count"))
                .build())
        .build();
```
得到结果：
```text
[ Entity[vertex=1,dimension=entity,properties=Properties[count=<java.lang.Integer>3]] --> 	[Entity[vertex=1,dimension=entity,properties=Properties[count=<java.lang.Integer>3]]] ]
[ Entity[vertex=4,dimension=entity,properties=Properties[count=<java.lang.Integer>1]] --> 		[Entity[vertex=4,dimension=entity,properties=Properties[count=<java.lang.Integer>1]]] ]
[ Entity[vertex=5,dimension=entity,properties=Properties[count=<java.lang.Integer>3]] --> 		[Entity[vertex=5,dimension=entity,properties=Properties[count=<java.lang.Integer>3]]] ]
[ Entity[vertex=6,dimension=entity,properties=Properties[count=<java.lang.Integer>30]] -->
	[] ]
```

**例 - 右全联接**
```java
GqlChain<Iterable<? extends MapTuple>> opChain = new GqlChain.Builder()
        .from(new Join.Builder<>()
                .input(inputKnowledges)
                .gql(new ScanKnowledge())
                .joinType(JoinType.FULL)
                .matchKey(MatchKey.RIGHT)
                .flatten(false)
                .matchMethod(new KnowledgeMatch("count"))
                .build())
        .build();
```
得到结果：
```text
[ [Entity[vertex=1,dimension=entity,properties=Properties[count=<java.lang.Integer>3]]] --> 	Entity[vertex=1,dimension=entity,properties=Properties[count=<java.lang.Integer>3]] ]
[ [] --> Edge[source=1,target=2,directed=true,dimension=edge,properties=Properties[count=<java.lang.Integer>3]] ]
[ [] --> Edge[source=1,target=4,directed=true,dimension=edge,properties=Properties[count=<java.lang.Integer>1]] ]
[ [] --> Entity[vertex=2,dimension=entity,properties=Properties[count=<java.lang.Integer>1]] ]
[ [] --> Edge[source=2,target=3,directed=true,dimension=edge,properties=Properties[count=<java.lang.Integer>2]] ]
[ [] --> Edge[source=2,target=4,directed=true,dimension=edge,properties=Properties[count=<java.lang.Integer>1]] ]
[ [] --> Edge[source=2,target=5,directed=true,dimension=edge,properties=Properties[count=<java.lang.Integer>1]] ]
[ [] --> Entity[vertex=3,dimension=entity,properties=Properties[count=<java.lang.Integer>2]] ]
[ [] --> Edge[source=3,target=4,directed=true,dimension=edge,properties=Properties[count=<java.lang.Integer>4]] ]
[ [Entity[vertex=4,dimension=entity,properties=Properties[count=<java.lang.Integer>1]]] --> 		Entity[vertex=4,dimension=entity,properties=Properties[count=<java.lang.Integer>1]] ]
[ [Entity[vertex=5,dimension=entity,properties=Properties[count=<java.lang.Integer>3]]] --> 		Entity[vertex=5,dimension=entity,properties=Properties[count=<java.lang.Integer>3]] ]
```

**例 - 左外联接**
```java
GqlChain<Iterable<? extends MapTuple>> opChain = new GqlChain.Builder()
        .from(new Join.Builder<>()
                .input(inputKnowledges)
                .gql(new ScanKnowledge())
                .joinType(JoinType.OUTER)
                .matchKey(MatchKey.LEFT)
                .matchMethod(new KnowledgeMatch("count"))
                .build())
        .build();
```
得到结果：
```text
[ Entity[vertex=6,dimension=entity,properties=Properties[count=<java.lang.Integer>30]] --> null ]
```

**例 - 右外联接**
```java
GqlChain<Iterable<? extends MapTuple>> opChain = new GqlChain.Builder()
        .from(new Join.Builder<>()
                .input(inputKnowledges)
                .gql(new ScanKnowledge())
                .joinType(JoinType.OUTER)
                .matchKey(MatchKey.RIGHT)
                .matchMethod(new KnowledgeMatch("count"))
                .build())
        .build();
```
得到结果：
```text
[ null --> Edge[source=1,target=2,directed=true,dimension=edge,properties=Properties[count=<java.lang.Integer>3]] ]
[ null --> Edge[source=1,target=4,directed=true,dimension=edge,properties=Properties[count=<java.lang.Integer>1]] ]
[ null --> Entity[vertex=2,dimension=entity,properties=Properties[count=<java.lang.Integer>1]] ]
[ null --> Edge[source=2,target=3,directed=true,dimension=edge,properties=Properties[count=<java.lang.Integer>2]] ]
[ null --> Edge[source=2,target=4,directed=true,dimension=edge,properties=Properties[count=<java.lang.Integer>1]] ]
[ null --> Edge[source=2,target=5,directed=true,dimension=edge,properties=Properties[count=<java.lang.Integer>1]] ]
[ null --> Entity[vertex=3,dimension=entity,properties=Properties[count=<java.lang.Integer>2]] ]
[ null --> Edge[source=3,target=4,directed=true,dimension=edge,properties=Properties[count=<java.lang.Integer>4]] ]
```

#### 函数工具
1. SchemaConversion：提供Schema对象与JsonString互转
2. AbutionGraphUtil：从分布式缓存中获取图实例
3. AggregatorUtil：可用于内存聚合图数据的工具，如在Flink中预聚合
4. JsonSerialiser：Object to JsonString 转换



### ExportKnowledge to GraphFrame
从AbutionGraph获取数据做为Spark GraphFrame。
```java
GraphFrame graphFrame = g.export().GraphFrame().dimEs().exec(new User());
```
> 注意：
因为DataFrame没有同时删除多列的功能，所以，不管选定几个字段，都会补全剩余字段为null值，得到的DF为全部属性，可自行剔除多余。
为减少内存占用，提高GraphFrames的性能，GetGraphFrameOfKnowledge不用指定entity维度。

语法参数：
```java
*  .isDirected()/unDirected()    //边是有向边还是无向边
*
*  .dimE("")
*     .has("",..).by(Predicte)
*     .groupBy("",..) .where().by(Predicte)
*     .transform("",..).by(Funtion).as("",..)
*     .props("",...)
*     .excludeProps("",...)
*
*  .dimV("")...
*
*  .dimEs("",...)
*  .dimVs("",...)
*
*  .global()
*     .has("",..).by(Predicte)
*     .groupBy("",..) .where().by(Predicte)
*     .transform("",..).by(Funtion).as("",..)
*     .props("",...)
*     .excludeProps("",...)
*
```
在操作链中使用Map操作将GraphFrame转化为Knowledge示例：
```java
Iterable<? extends Knowledge> results = g.export()
        .GraphFrame().dimEs()
        .Map().from(new GraphFrameToIterableRow()).then(new RowToKnowledgeGenerator())
        .exec(new User());
```

### ExportKnowledge to DataFrame
从AbutionGraph获取数据做为Spark DataFrame，使用方法与GraphFrame同。
语法：
```java
 *  .isDirected()/unDirected()    //边是有向边还是无向边
 *
 *  .dimE("")
 *     .has("",..).by(Predicte)
 *     .groupBy("",..) .where().by(Predicte)
 *     .transform("",..).by(Funtion).as("",..)
 *     .props("",...)
 *     .excludeProps("",...)
 *
 *  .dimV("")...
 *
 *  .dimEs("",...)
 *  .dimVs("",...)
 *
 *  .global()
 *     .has("",..).by(Predicte)
 *     .groupBy("",..) .where().by(Predicte)
 *     .transform("",..).by(Funtion).as("",..)
 *     .props("",...)
 *     .excludeProps("",...)
```

语句示例：
```java
Dataset<Row> dataFrame = g.export()
        .GraphFrame().dimEs()
        .exec(new User());
```
